#!/bin/bash

EMERGE_CONF=${EMERGE_CONF:-/etc/emerge}

PACMAN='pacman'
if [ -e "$EMERGE_CONF/emerge.conf" ]; then
	. "$EMERGE_CONF/emerge.conf"
fi

list_doesnot_contain() {
	local target="$1"
	shift
	while [ -n "$1" ]; do
		[ "$target" = "$1" ] && return 1
		shift
	done
	return 0
}

filter_conf() {
	local line
	while read line; do
		if [ -n "$(echo $line|grep '^<')" ]; then
			import_set $(echo $line|sed 's/^<//')
		elif [ -n "$(echo $line|grep '^@')" ]; then
			$PACMAN -Sqg $(echo $line|sed 's/^@//')
		else
			echo $line
		fi
	done
}

filter_exclude_optdepended() {
	xargs -r $PACMAN -Qi | awk '/^Name/{name=$3} /^Optional For\s*:\s*\S/{ if ( $4 == "None" ) { print name } }'
}

filter_only_explicit() {
	xargs -r $PACMAN -Qi | awk '/^Name/{name=$3} /^Install Reason.*Explicitly installed$/{ print name }'
}

import_set() {
	local includecmd="$EMERGE_CONF/$1.set"
	local maskcmd="$EMERGE_CONF/$1.mask"

	if [ ! -e "$maskcmd" ]; then
		maskcmd="$( which true )"
	fi

	[ -x "$includecmd" ] || includecmd="cat $includecmd"
	[ -x "$maskcmd" ] || maskcmd="cat $maskcmd"

	local include=$($includecmd|filter_conf)
	local mask=$($maskcmd|filter_conf)
	for pkg in $include; do
		if list_doesnot_contain $pkg $mask ; then
			echo $pkg
		fi
	done
}

extras() {
	local line
	while read line; do
		for pkg in $line; do
			list_doesnot_contain $pkg $@ && echo $pkg
		done
	done
}

pacsync_update_world() {
explicit=$(import_set world)

explicit_rm=$($PACMAN -Qqe|extras $explicit)
explicit_add=$(echo $explicit|extras $($PACMAN -Qqe))

cat  <<!
The following packages will be added to the explict set:
$explicit_add

The following packages will be removed from the explicit set:
$explicit_rm

press enter to continue, or Ctrl-C to stop.
!
read

toinstall=""
[ -z "$explicit_rm" ] || $PACMAN -D --asdeps $explicit_rm || exit 1
if [ -n "$explicit_add" ]; then
	for pkg in $explicit_add; do
		if $PACMAN -Q "$pkg" > /dev/null 2>&1; then
			$PACMAN -D --asexplicit $pkg
		else
			toinstall="$toinstall $pkg"
		fi
	done
fi
if [ -n "$toinstall" ]; then
	$PACMAN -Su --noconfirm $toinstall || exit 1
else
	$PACMAN -Su --noconfirm
fi
orphans=$( $PACMAN -Qqtd | filter_exclude_optdepended )
[ -z "$orphans" ] || $PACMAN -Rs --noconfirm $orphans || exit 1
}

rebuild_world_set() {
	local SETFILE="$EMERGE_CONF/world.set"
	if [ -e "$SETFILE" ]; then
		local SUFFIX=".backup-"
		local DATE=$(date +%Y-%m-%d)
		local TIME="_$(date +%H%M)"
		local SEC="$(date +%S)"
		local TFN=""
		# determine backup filename
		if [ ! -e "$SETFILE$SUFFIX$DATE" ]; then
			TFN="$SETFILE$SUFFIX$DATE"
		elif [ ! -e "$SETFILE$SUFFIX$DATE$TIME" ]; then
			TFN="$SETFILE$SUFFIX$DATE$TIME"
		elif [ ! -e "$SETFILE$SUFFIX$DATE$TIME$SEC" ]; then
			TFN="$SETFILE$SUFFIX$DATE$TIME$SEC"
		else
			local PREFIX="${SETFILE}${SUFFIX}${DATE}${TIME}${SEC}_"
			TFN="$PREFIX$SECONDS$RANDOM"
			while [ ! -e "$TFN" ]; do
				TFN="$PREFIX$SECONDS$RANDOM"
			done
		fi
		echo ">>> backing up existing world.set file as $TFN"
		mv "$SETFILE" "$TFN" || exit $?
	fi
	echo ">>> generating world.set from current system pacman config..."
	$PACMAN -Qqe > "$SETFILE.raw"
	# optimize world.set
	local PKG
	local PGROUPS
	local REQDBY
	local GROUP
	local PARENTS
	local PARENT
	local CHILDREN
	local LINE
	echo ">>> checking for dependencies..."
	[ -f "$SETFILE.checkdeps" ] && rm "$SETFILE.checkdeps"
	[ -f "$SETFILE.checkdeps.groups" ] && rm "$SETFILE.checkdeps.groups"
	local PKGIDX=0
	local RAWLINES=$( wc -l < "$SETFILE.raw" )
	for PKG in $( cat "$SETFILE.raw" ) ; do
		$PACMAN -Qi "$PKG" > /tmp/emerge_pacman_Qi
		PGROUPS=$( egrep '^Groups *: ' < /tmp/emerge_pacman_Qi | cut -d: -f2 | sed -r 's/^ +//g ; s/ +$//g' )
		REQDBY=$( egrep '^Required By *: ' < /tmp/emerge_pacman_Qi | cut -d: -f2 | sed -r 's/^ +//g ; s/ +$//g' )
		# determine parents
		PARENTS=""
		if [ "$PGROUPS" != "None" ]; then
			for GROUP in $PGROUPS ; do
				PARENTS="$PARENTS @$GROUP"
			done
		fi
		if [ "$REQDBY" != "None" ]; then
			for GROUP in $REQDBY ; do
				PARENTS="$PARENTS $GROUP"
			done
		fi
		if [ -n "$PARENTS" ]; then
			printf "%-20s:%s\n" "$PKG" "$PARENTS" >> "$SETFILE.checkdeps"
			for GROUP in $PARENTS ; do
				if [[ $GROUP =~ ^@ ]]; then
					GROUP=${GROUP#@}
					echo "$GROUP" >> "$SETFILE.checkdeps.groups"
				fi
			done
		fi
		if [ -t 0 ]; then
			(( ++PKGIDX ))
			printf "Package %i/%i...\r" $PKGIDX $RAWLINES
		fi
	done
	[ -f /tmp/emerge_pacman_Qi ] && rm /tmp/emerge_pacman_Qi
	# uniqify group list
	sort -u "$SETFILE.checkdeps.groups" > "$SETFILE.checkdeps.groups.tmp" && mv "$SETFILE.checkdeps.groups.tmp" "$SETFILE.checkdeps.groups"
	# change dependency of packages that would be included anyhow
	echo ">>> simplify package list with deep dependency checks..."
	while read LINE ; do
		LINE=$( sed -r 's/^(\S+) +: +/\1\t/g ; s/@\S+( +|$)//g' <<<"$LINE" )
		read PKG PGROUPS <<<"$LINE"
		if ! fgrep -xq "$PKG" "$SETFILE.raw" ; then
			true
		elif [ -n "$PGROUPS" ]; then
			echo -n "$PKG is explicit in set"
			REQDBY=""
			for PARENT in $PGROUPS ; do
				if $PACMAN -T "$PARENT" >/dev/null ; then
					REQDBY="$REQDBY $PARENT"
				fi
			done
			if [ -n "$REQDBY" ]; then
				echo ", but gets pulled in by:$REQDBY"
				fgrep -xv "$PKG" "$SETFILE.raw" > "$SETFILE.tmp" && mv "$SETFILE.tmp" "$SETFILE.raw"
				echo "$PKG" >> "$SETFILE.was_explicit"
			else
				echo -en "\r                                        \r"
			fi
		fi
	done < "$SETFILE.checkdeps"
	if [ -s "$SETFILE.was_explicit" ]; then
		echo ">>> marking explicit packages as deps when also included..."
		if [ "$UID" == 0 -o "$EUID" == 0 ]; then
			$PACMAN -D --asdeps $( cat "$SETFILE.was_explicit" )
			rm "$SETFILE.was_explicit"
		else
			echo "**********************************************" >&2
			echo "*** current user is not root" >&2
			echo "*** unable to mark explicit packages: $( cat "$SETFILE.was_explicit" )" >&2
			echo "*** explicit package list is preserved at: $SETFILE.was_explicit" >&2
			echo "*** run the following as root: $PACMAN -D --asdeps \$( cat \"$SETFILE.was_explicit\" )" >&2
			echo "**********************************************" >&2
		fi
	fi
	# replace group children with @group
	echo ">>> checking for dependencies in groups..."
	for GROUP in $( cat "$SETFILE.checkdeps.groups" ) ; do
		CHILDREN=$( $PACMAN -Sg "$GROUP" | sed "s/^$GROUP //g" )
		if [ -n "$CHILDREN" ] && $PACMAN -T $CHILDREN >/dev/null ; then
			# only replace if at least 1 child is explicitly installed
			local EXPLICIT_CHILDREN=$( filter_only_explicit <<<"$CHILDREN" )
			if [ -z "$EXPLICIT_CHILDREN" ]; then
				continue
			fi
			echo -n "replacing @$GROUP children in world.set: "
			for PKG in $CHILDREN ; do
				echo -n "$PKG "
				fgrep -xv "$PKG" "$SETFILE.raw" > "$SETFILE.tmp" && mv "$SETFILE.tmp" "$SETFILE.raw"
			done
			echo "@$GROUP" >> "$SETFILE.raw"
			echo ""
		fi
	done
	echo ">>> sorting packages..."
	sort -u "$SETFILE.raw" > "$SETFILE.raw.tmp" && mv "$SETFILE.raw.tmp" "$SETFILE.raw"
	echo ">>> moving temporary file to $SETFILE"
	mv "$SETFILE.raw" "$SETFILE"
	echo ">>> cleaning up..."
	[ -f "$SETFILE.checkdeps" ] && rm "$SETFILE.checkdeps"
	[ -f "$SETFILE.checkdeps.groups" ] && rm "$SETFILE.checkdeps.groups"
}

ensure_world_set_exists() {
	if [ ! -e "$EMERGE_CONF/world.set" ]; then
		echo ">>> world set file '$EMERGE_CONF/world.set' does not exist."
		rebuild_world_set
	fi
}

pacman_update_world() {
	ensure_world_set_exists
	pacsync_update_world
}

show_help() {
	cat <<<"
usage: $( basename "$0" ) {-h|--help}
       $( basename "$0" ) {--rebuild-world-set}
       $( basename "$0" ) [options] {world|@world}
standalone options:
       -h --help             show this help text
       --rebuild-world-set   generate new world.set from pacman database
"
}

# command line argument parsing for common emerge flags
REBUILD_WORLD_SET=0
HELP=0
while [[ $# -gt 0 ]]; do
	ARG="$1"
	shift
		case "$ARG" in
			-h|--help) HELP=1 ;;
			--rebuild-world-set) REBUILD_WORLD_SET=1 ;;
			world|@world) true ;;
			# unknown commands
			*)
					HELP=1
					echo "error: invalid argument: $ARG" >&2
				;;
		esac
done

# determine operating mode:
if [ "$HELP" != "0" ]; then
	show_help
	exit 1
elif [ $REBUILD_WORLD_SET == 1 ]; then
	rebuild_world_set
else
	pacman_update_world
fi
